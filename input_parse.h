#ifndef CPROJECTSCALCULATOR_INPUT_PARSE_H
#define CPROJECTSCALCULATOR_INPUT_PARSE_H

#include <stdio.h>

// численные константы
/// число зарезервированных идентификаторов под функции и математические константы
#define NUM_OF_RESERVED 24
/// число операторов: арифметических операции, скобки, равно и запятая
#define NUM_OF_OPERATIONS 9
/// максимальная длинна идентификатора
#define LEN_OF_IDENTIFIER 32
/// максимальное количество пкркменных объявленных в одной строке
#define MAX_VARS_IN_LINE 8

// коды ошибок
/// если выражение содержит неправильную скобочную последовательность
#define INCORRECT_BRACKETS 101
/// встречен символ, который не может находиться внутри арифметического выражения
#define ILLEGAL_CHAR 102
/// переданы скобки не содержащие чего-либо
#define EMPTY_BRACKETS 103
/// две переменные или константы идут последовательно без оператора между
#define FOLLOWING_CONSTANTS 104
/// внутри логарифма или функции возведения в степень нет запятой
#define WRONG_LOG_POW 105
/// слева от равно стоит не переменная
#define CANNOT_ASSIGN 106
/// использование переменной до ее объявления и присваивания ей значения
#define NOT_ASSIGNED 107

// вывод сообщенй об ошибке
/// массив сообщений об ошибках
extern char * errorMesseges[];
/// фунция выводящая сообщене c cоответствующим кодом на экран
void errorLog(int code);

/// массив содержащий все зарезервированные слова, а также символы операторов
extern const char * RESERVED[NUM_OF_RESERVED];

/** программные константы типа токена: идентификатор, оператор или числовая константа
*   записаны в поле type каждого токена и определяют поведение токена **/
typedef enum { identifier, operation, constant } TokenType;

/** программные константы дейсвия токена, если токен представляет функцию или оператор,
*   то в поле act токена стоит соответствующая константа, иначе константа none указывющая на то, что у токена нет
*   действия примером таких токенов являются переменные **/
typedef enum {
    add, sub, mul, dev, car, eqv, bro, brc, cma,
    sin, cos, tg, log, ln, srt, pov, abc, exp, real, img, mag, phs,
    E, PI, none } Function;

/** ключевая структура парсинга, каждый отделный элемент входного выражения представлен именно этим типом
  * поле type определяет тип токена, возможные типы представленны перечисление TokenType
  * далее если type == constant, to токен имеет два поля value - числовое значение и imag - флаг о том, что число мнимое
  * если type == identifier то токен представляет собой функцию или переменую и имеет два поля varID - код переменной
  * и act - код действия функции из перечислени Function, none для переменных
  * и если type == operation, то для токена также определены varID и act, но используется только act **/
typedef struct {
    TokenType type;
    union {
        struct { double value; int imag; };
        struct { Function act; int varID; };
    };
} Token;

/// массив из токенов, содержит указатель на начало массива и количесво элементов в нем
typedef struct {
    int size;
    Token * self;
} TokenArray;

/** сырой тип введеных данных, используется, чтобы подсчитать сколько максимально байт понадобится выделить для
*   хранения возможных переменны, подсчитывается количество строк, все считанное с консоли выражение сохраняется в файл **/
typedef struct {
    int lineCount; // количество строк в выражении
    FILE *savedFile; // файл с сохраненными данными
    int bufferSize; // суммарная длинна ввех строк в выражении
} InputExpression;

/** итоговый тип выражения после парсинга, каждая строка представлена массивом токенов, поэтому структура хранит
*   указатель lines на массив массивов токенов
*   также подсчитано число различных переменных встречающихся в выражении, каждой переменной присвоен ее код из от 0 до
*   varCount, этот код сохранен в поле varID для каждого токена представляющего перемнную **/
typedef struct {
    TokenArray * lines;
    int lineCount;
    int varCount;
} ParsedExpression;


/// основной метод парсинга, принимает объект InputExpression и возвращает объект ParsedExpression
ParsedExpression parseExpression();

// булевые методы проверки токена на то, какая информация в нем хранится
/// являеся ли токен численной константой
int isConstant(Token *t);
/// является ли токен переменой
int isVariable(Token *t);
/// является ли токен функцией
int isFunc(Token *t);
/// является ли токен оператором (арифметическим, скобкой, равно или запятой)
int isOperator(Token *t);
/** проверка на то, что токен не имеет действия,
 *  то есть является переменной или численной константой **/
int isFinal(Token *t);

/// метод для удаления и освобождения ресурсов занятых во время обработки
void deletePe(ParsedExpression pe);
#endif //CPROJECTSCALCULATOR_INPUT_PARSE_H
